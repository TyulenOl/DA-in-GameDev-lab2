# АНАЛИЗ ДАННЫХ И ИСКУССТВЕННЫЙ ИНТЕЛЛЕКТ [in GameDev]
Отчет по лабораторной работе #1 выполнил(а):
- Тюленев Сергей Николаевич
- РИ210912

Отметка о выполнении заданий (заполняется студентом):

| Задание | Выполнение | Баллы |
| ------ | ------ | ------ |
| Задание 1 | * | 60 |
| Задание 2 | * | 20 |
| Задание 3 | * | 20 |


Работу проверили:
- к.т.н., доцент Денисов Д.В.
- к.э.н., доцент Панов М.А.
- ст. преп., Фадеев В.О.

[![N|Solid](https://cldup.com/dTxpPi9lDf.thumb.png)](https://nodesource.com/products/nsolid)

[![Build Status](https://travis-ci.org/joemccann/dillinger.svg?branch=master)](https://travis-ci.org/joemccann/dillinger)

## Цель работы
Ознакомиться с основными операторами зыка Python на примере реализации линейной регрессии.

## Задание 1
### Написать программы Hello World на Python и Unity.
- Hello World на Python в Google.Colab
![Screenshot_1](https://user-images.githubusercontent.com/100992984/191791503-36d9d8cf-accf-44d8-805f-d56baa58f0e2.png)
![Screenshot_2](https://user-images.githubusercontent.com/100992984/191791517-78358c55-f238-4bc0-a87d-716a9b6d6bd6.png)
- Вывод Hello World в консоль Unity
![Screenshot_3](https://user-images.githubusercontent.com/100992984/191831042-0295bd75-b4b9-493b-a12c-adfb42aeca52.png)


## Задание 2
### Пошагово выполнить каждый пункт раздела "ход работы" с описанием и примерами реализации задач
### Ход работы:
* #### Произвести подготовку данных для работы с алгоритмом линейной регрессии. 10 видов данных были установлены случайным образом, и данные находились в линейной зависимости. Данные преобразуются в формат массива, чтобы их можно было вычислить напрямую при использовании умножения и сложения.

```py
In [ ]:
import numpy as np
import matplotlib.pyplot as plt

x = [3, 21, 22, 34, 54, 34, 55, 67, 89, 99]
x = np.array(x)
y = [2, 22, 24, 65, 79, 82, 55, 130, 150, 199]
y = np.array(y)

plt.scatter(x, y)
plt.show()

```
![Screenshot_4](https://user-images.githubusercontent.com/100992984/191831208-37e7a64c-2165-4f77-8e7e-265043770c9f.png)


* #### Определите связанные функции. Функция модели: определяет модель линейной регрессии wx+b. Функция потерь: функция потерь среднеквадратичной ошибки. Функция оптимизации: метод градиентного спуска для нахождения частных производных w и b.

```py
import numpy as np
import matplotlib.pyplot as plt

x = [3, 21, 22, 34, 54, 34, 55, 67, 89, 99]
x = np.array(x)
y = [2, 22, 24, 65, 79, 82, 55, 130, 150, 199]
y = np.array(y)

plt.scatter(x, y)


def model(a, b, x):
    return a * x + b


def loss_function(a, b, x, y):
    num = len(x)
    prediction = model(a, b, x)
    return (0.5 / num) * (np.square(prediction - y)).sum()


def optimize(a, b, x, y):
    num = len(x)
    prediction = model(a, b, x)
    da = (1.0 / num) * ((prediction - y) * x).sum()
    db = (1.0 / num) * ((prediction - y).sum())
    a = a - Lr * da
    b = b - Lr * db
    return a, b


def iterate(a, b, x, y, times):
    for i in range(times):
        a, b = optimize(a, b, x, y)
    return a, b
```
* #### Начать итерацию 
1. Инициализаци и модель итеративной оптимизации 
![Screenshot_5](https://user-images.githubusercontent.com/100992984/191805481-8576660f-dc87-4d64-942c-6025ebe22801.png)

2. На второй итерации отображаются значения параметров, значения потрерь и эффекты визуализации после итерации
![Screenshot_6](https://user-images.githubusercontent.com/100992984/191805510-be494e4e-0563-4b03-b4d9-4d42dbe5b96c.png)

3. Третья итерация показывает значения параметров, значения потерь и визуализацию после итерации
![Screenshot_7](https://user-images.githubusercontent.com/100992984/191805530-b95bfcc6-023c-4bdb-b21d-bd9fad611a92.png)

4. На четвертой итерации отображаются значения параметров, значения потерь и эффекты визуализации
![Screenshot_8](https://user-images.githubusercontent.com/100992984/191805575-6e388906-f91a-46ff-a5ba-4000510b1fdd.png)

5. Пятая итерация показывает значения параметра, значение потреь и эффект визуализации после итерации
![Screenshot_9](https://user-images.githubusercontent.com/100992984/191805610-781b7ec1-1b6e-4374-bf50-53812128a61c.png)

6. 10000-я итерация, показывающая значения параметров, потери и визуализацию после итерации
![Screenshot_10](https://user-images.githubusercontent.com/100992984/191805629-3dda2647-29d5-414e-87e2-00ecaae5dee6.png)


## Задание 3
### Изучить код на Python и ответить на вопросы:
### 1. Должна ли величина loss стремиться к нулю при изменении исходных данных? Ответьте на вопрос, приведите пример выполнения кода, который подтверждает ваш ответ.
Величина loss будет равна нулю, если исходные данные x и y будут заданы линейной функцией и коэффициент b = 0
![Screenshot_13](https://user-images.githubusercontent.com/100992984/191829750-eaeb35b6-e298-4cc4-907b-834148887ec9.png)


### 2. Какова роль параметра Lr? Ответьте на вопрос, приведите пример выполнения кода, который подтверждает ваш ответ. В качестве эксперимента можете изменить значение параметра.
Параметр Lr отвечает за величину шага, от которой зависит, насколько быстро или медленно будет происходить достижение оптимальных значений. 
Чем больше параметр Lr, тем быстее будет происходить возрастание графика.
Так, при Lr=0.0002 график за 10 повторений достигает примерно тех же значений, что и при Lr=0.000001 за 10000 повторений.
![Screenshot_11](https://user-images.githubusercontent.com/100992984/191812930-d7bdd33b-474d-4500-bea5-cbe859c0f608.png)
![Screenshot_12](https://user-images.githubusercontent.com/100992984/191812939-5be2cda7-265f-4694-96d5-1a5721b258fa.png)

При очень маленьких значения Lr можно получить более точный график, но он будет расти медленнее и следовательно, потребуется больше времени для получения оптимального решения. При слишком больших значениях Lr график может и вовсе пройти мимо минимального значения.

## Выводы

В ходе лабораторной работы:
- Установил и запустил програмное обеспечение для работы с Python, а таже Unity.
- Написал маленькие программы по выводу Hello world в Google.Colab и в консоль Unity.
- Ознакомился с работой на Python на примере алгоритма линейной регрессии.
- Рассмотрел работу линейной регрессии.
